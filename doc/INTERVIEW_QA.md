# 面试突击指南 (Interview Q&A)

这份文档整理了本项目涉及的核心面试题，特别是针对简历上的“高性能优化”亮点。

## 亮点 1: 时间轮 (Timing Wheel) 优化心跳

**Q: 为什么不用 Go 原生的 `time.AfterFunc` 或 `Ticker` 做心跳检测？**
**A:**
- **原生 Timer 的开销**: Go 的 runtime 维护一个最小堆 (Min-Heap) 来管理所有定时器。插入和删除的时间复杂度是 `O(log N)`。
- **海量连接场景**: 当有 100 万个连接时，每个连接都需要独立的心跳定时器。频繁的连接断开/重连会导致频繁的堆调整，消耗大量 CPU，并且锁竞争激烈。
- **时间轮优势**: 我们实现了 **Hashed Timing Wheel**。它本质上是一个环形数组（类似时钟）。
    - **插入/删除**: 复杂度仅仅是 `O(1)`（数组索引访问）。
    - **执行**: 只需要每秒转动一次指针，处理当前槽（Bucket）里的链表即可。
    - **效果**: 无论连接数多少（1万还是100万），CPU 消耗几乎恒定且极低。

## 亮点 2: MySQL 异步批量写入

**Q: 异步写入会不会导致消息丢失？断电了怎么办？**
**A:**
- **初步方案**: 只是简单的 `go func` 异步写，断电确实会丢。
- **可靠性设计 (此项目方案)**: 我结合了 **消息队列 (RabbitMQ)** 实现了**零丢失方案**。
    1. **Hold ACK**: Logic 服务从 MQ 收到消息后，**不立即回复 ACK**。
    2. **Buffer**: 将消息放入内存 Buffer。
    3. **Batch Write**: 当 Buffer 满或超时，批量插入 MySQL。
    4. **Callback**:
        - 如果 MySQL 写入**成功** -> 回调 RabbitMQ 发送 **ACK**（消息确认消费）。
        - 如果 MySQL 写入**失败**或**进程崩溃** -> RabbitMQ 收不到 ACK（连接断开），会将这些消息**重新投递**给其他 Logic 节点。
- **结论**: 虽然是异步，但在“最终一致性”层面保证了数据不丢。

**Q: 为什么批量写入比单条写入快？**
**A:**
- **减少 IO 次数**: 100 条消息单条插入需要 100 次网络 RTT 和 100 次磁盘 IOSync。
- **合并事务**: 批量插入 (`INSERT VALUES (...), (...), ...`) 只需要 1 次网络交互和 1 次磁盘 IO。
- **吞吐量提升**: 经过实测，吞吐量通常能提升 10 到 50 倍以上。

## 亮点 3: sync.Pool 零拷贝/零分配

**Q: 在 Gateway 中你是怎么优化内存的？**
**A:**
- **痛点**: Gateway 负责高频的消息转发。每次将 Go Struct 转为 JSON `[]byte` 时，标准库 `json.Marshal` 都会申请新的内存。对于高并发场景，这会产生海量的小对象，导致 GC (Garbage Collection) 频繁触发 STW。
- **优化**:
    - 我引入了 `sync.Pool` 来复用 `bytes.Buffer` 对象。
    - 配合 `json.NewEncoder(buf).Encode()`，将 JSON 直接写入复用的 Buffer 中，避免了申请临时的 `[]byte`。
    - 发送完网络数据后，手动 `Reset()` 并归还 Buffer。
- **收益**: 大幅减少了短寿命对象的分配，减轻了 GC 压力。

## 架构相关

**Q: 为什么 Logic 和 Gateway 要拆分？**
**A:**
- **Gateway (IO 密集型)**: 负责维持海量 WebSocket 连接，不仅连接数多，而且网络带宽压力大。它应该是**无状态**的，方便水平扩容 (Scale Out)。
- **Logic (CPU 密集型)**: 负责复杂的业务逻辑、数据库交互、Proto 序列化等。
- **隔离故障**: 如果 Logic 层的代码有 Bug 导致 Panic，不会影响 Gateway 层的连接维持（用户不会断线重连，体验更好）。
